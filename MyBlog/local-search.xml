<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/11/03/hello-world/"/>
    <url>/2021/11/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>P2024 [NOI2001]食物链</title>
    <link href="/2020/07/29/P2024%20%5BNOI2001%5D%E9%A3%9F%E7%89%A9%E9%93%BE/"/>
    <url>/2020/07/29/P2024%20%5BNOI2001%5D%E9%A3%9F%E7%89%A9%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A 吃 B，B 吃 C，C 吃 A。</p><p>现有 N 个动物，以 1 － N 编号。每个动物都是 A,B,C 中的一种，但是我们并不知道它到底是哪一种。</p><p>有人用两种说法对这 N 个动物所构成的食物链关系进行描述：</p><ul><li>第一种说法是 <code>1 X Y</code>，表示 X 和 Y 是同类。</li><li>第二种说法是<code>2 X Y</code>，表示 X 吃 Y 。</li></ul><p>此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p><ul><li>当前的话与前面的某些真的话冲突，就是假话</li><li>当前的话中 X 或 Y 比 N 大，就是假话</li><li>当前的话表示 X 吃 X，就是假话</li></ul><p>你的任务是根据给定的 N 和 K 句话，输出假话的总数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个整数，N，K，表示有 N 个动物，K 句话。第二行开始每行一句话（按照题目要求，见样例）</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，一个整数，表示假话的总数。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入 #1</strong>复制</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">100 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">101</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>输出 #1</strong>复制</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>1 ≤ N ≤ 5 ∗ 10^4</p><p>1 ≤ K ≤ 10^5</p><hr><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>并查集能维护连通性、传递性，通俗地说，<code>亲戚的亲戚是亲戚</code>。</p><p>然而当我们需要维护一些对立关系，比如 <code>敌人的敌人是朋友</code> 时，正常的并查集就很难满足我们的需求。但是带权并查集就可以解决。</p><p>带权并查集的诠释是这样的：</p><h3 id="在对并查集进行路径压缩和合并操作时，这些权值具有一定属性，即可将他们与父节点的关系，变化为与所在树的根结点关系。"><a href="#在对并查集进行路径压缩和合并操作时，这些权值具有一定属性，即可将他们与父节点的关系，变化为与所在树的根结点关系。" class="headerlink" title="在对并查集进行路径压缩和合并操作时，这些权值具有一定属性，即可将他们与父节点的关系，变化为与所在树的根结点关系。"></a>在对并查集进行路径压缩和合并操作时，这些权值具有一定属性，即可将他们与父节点的关系，变化为与所在树的根结点关系。</h3><p>也就是说，权值代表着<strong>当前节点与父节点的某种关系（即使路径压缩了也是这样）</strong>，通过两者关系，也可以将同一棵树下两个节点的关系表示出来。</p><hr><p>而P2024《食物链》这道题，又属于加权并查集下的分支：</p><h3 id="种类并查集"><a href="#种类并查集" class="headerlink" title="种类并查集"></a>种类并查集</h3><p>由题意得，动物一共只有A,B,C三种，<strong>也就是说只要确定了一种动物的种类和他们的关系（即权值），其他的动物的种类也就知道了。</strong></p><p>我们用re数组表示编号i与父亲节点的权值关系，由于只有三种动物，所以权值也只有三种：0–&gt;同种动物，1–&gt;捕食关系，2–&gt;被捕食关系，转移时便可以采用对3取模来实现。<strong>（初始化为0，即自己与自己为同种动物）</strong></p><h3 id="那么第一个问题，就是如何在查找与合并时转移这种权值？"><a href="#那么第一个问题，就是如何在查找与合并时转移这种权值？" class="headerlink" title="那么第一个问题，就是如何在查找与合并时转移这种权值？"></a>那么第一个问题，就是如何在查找与合并时转移这种权值？</h3><p><strong>1.合并</strong>：并查集合并的本质就是一棵树认另一棵树做父亲，把树根相连即可，但是能否也把权值直接赋值呢（比如1操作就直接赋值为1)？ <strong>当然不行，因为给你的a,b是树下节点，还有考虑各自与树根的关系。</strong> 也就说，推出A,B各自与根的关系，就可以实现树根权值的连接了。</p><h4 id="设F1与F2分别为A-B的根，两者权值关系为re-F1-，A与F1的权值关系是re-A-，B与F2的权值关系是re-B-，A与B的权值关系为x。"><a href="#设F1与F2分别为A-B的根，两者权值关系为re-F1-，A与F1的权值关系是re-A-，B与F2的权值关系是re-B-，A与B的权值关系为x。" class="headerlink" title="设F1与F2分别为A,B的根，两者权值关系为re[F1]，A与F1的权值关系是re[A]，B与F2的权值关系是re[B]，A与B的权值关系为x。"></a>设F1与F2分别为A,B的根，两者权值关系为re[F1]，A与F1的权值关系是re[A]，B与F2的权值关系是re[B]，A与B的权值关系为x。</h4><p><img src="http://m.qpic.cn/psb?/V12Dh9TV392r4Z/VlNgTUtSs9u25rTjpaItmzH8InYBjF0z9bbEGPvqG2Q!/b/dFkAAAAAAAAA&bo=MwPMAQAAAAADB98!&rf=viewer_4" alt="img"></p><h2 id="由图得，re-f1-x-re-b-re-a"><a href="#由图得，re-f1-x-re-b-re-a" class="headerlink" title="由图得，re[f1]=x+re[b]-re[a]"></a>由图得，re[f1]=x+re[b]-re[a]</h2><p>由于可能会造成re[b]-re[a]&lt;0的情况，所以加3再对三取模。又因为x已知为0或1（要么是同种动物，要么是捕食关系），所以最终结果为：</p><h4 id="re-f1-re-b-re-a-3-3或re-f1-1-re-b-re-a-3-3"><a href="#re-f1-re-b-re-a-3-3或re-f1-1-re-b-re-a-3-3" class="headerlink" title="re[f1]=(re[b]-re[a]+3)%3或re[f1]=(1+re[b]-re[a]+3)%3;"></a>re[f1]=(re[b]-re[a]+3)%3或re[f1]=(1+re[b]-re[a]+3)%3;</h4><p><strong>2.查找（路径压缩）</strong>：路径压缩就是在搜索的时候找到最远的祖先，然后将父亲节点赋值，对于权值而言，就是找出权值与最远祖先之前所有边权传递的过程，找出节点与父亲节点的关系，依次传递即可。</p><h4 id="设在同一树内，3号节点父亲是2号，2号父亲是根1号。与父亲的关系依次为re-3-，re-2-，路径压缩后权值为re-3-撇。"><a href="#设在同一树内，3号节点父亲是2号，2号父亲是根1号。与父亲的关系依次为re-3-，re-2-，路径压缩后权值为re-3-撇。" class="headerlink" title="设在同一树内，3号节点父亲是2号，2号父亲是根1号。与父亲的关系依次为re[3]，re[2]，路径压缩后权值为re[3]撇。"></a>设在同一树内，3号节点父亲是2号，2号父亲是根1号。与父亲的关系依次为re[3]，re[2]，路径压缩后权值为re[3]撇。</h4><p><img src="http://m.qpic.cn/psb?/V12Dh9TV392r4Z/9BkFnWb79*SAYQfTZfqLc6Hy1CiYndvWdLLL5tmoUis!/b/dEcBAAAAAAAA&bo=2wKxAQAAAAADB0s!&rf=viewer_4" alt="img"></p><h3 id="显然，re-3-撇-re-3-re-2-3，别忘了取模。"><a href="#显然，re-3-撇-re-3-re-2-3，别忘了取模。" class="headerlink" title="显然，re[3]撇=(re[3]+re[2])%3，别忘了取模。"></a>显然，re[3]撇=(re[3]+re[2])%3，别忘了取模。</h3><p>我们用re数组表示编号i与父亲节点的权值关系，由于只有三种动物，所以权值也只有三种：0–&gt;同种动物，1–&gt;捕食关系，2–&gt;被捕食关系，转移时便可以采用对3取模来实现。<strong>（初始化为0，即自己与自己为同种动物）</strong></p><h3 id="那么第一个问题，就是如何在查找与合并时转移这种权值？-1"><a href="#那么第一个问题，就是如何在查找与合并时转移这种权值？-1" class="headerlink" title="那么第一个问题，就是如何在查找与合并时转移这种权值？"></a>那么第一个问题，就是如何在查找与合并时转移这种权值？</h3><p><strong>1.合并</strong>：并查集合并的本质就是一棵树认另一棵树做父亲，把树根相连即可，但是能否也把权值直接赋值呢（比如1操作就直接赋值为1)？ <strong>当然不行，因为给你的a,b是树下节点，还有考虑各自与树根的关系。</strong> 也就说，推出A,B各自与根的关系，就可以实现树根权值的连接了。</p><h4 id="设F1与F2分别为A-B的根，两者权值关系为re-F1-，A与F1的权值关系是re-A-，B与F2的权值关系是re-B-，A与B的权值关系为x。-1"><a href="#设F1与F2分别为A-B的根，两者权值关系为re-F1-，A与F1的权值关系是re-A-，B与F2的权值关系是re-B-，A与B的权值关系为x。-1" class="headerlink" title="设F1与F2分别为A,B的根，两者权值关系为re[F1]，A与F1的权值关系是re[A]，B与F2的权值关系是re[B]，A与B的权值关系为x。"></a>设F1与F2分别为A,B的根，两者权值关系为re[F1]，A与F1的权值关系是re[A]，B与F2的权值关系是re[B]，A与B的权值关系为x。</h4><p>![img](P2024 [NOI2001]食物链.assets/psb)</p><h2 id="由图得，re-f1-x-re-b-re-a-1"><a href="#由图得，re-f1-x-re-b-re-a-1" class="headerlink" title="由图得，re[f1]=x+re[b]-re[a]"></a>由图得，re[f1]=x+re[b]-re[a]</h2><p>由于可能会造成re[b]-re[a]&lt;0的情况，所以加3再对三取模。又因为x已知为0或1（要么是同种动物，要么是捕食关系），所以最终结果为：</p><h4 id="re-f1-re-b-re-a-3-3或re-f1-1-re-b-re-a-3-3-1"><a href="#re-f1-re-b-re-a-3-3或re-f1-1-re-b-re-a-3-3-1" class="headerlink" title="re[f1]=(re[b]-re[a]+3)%3或re[f1]=(1+re[b]-re[a]+3)%3;"></a>re[f1]=(re[b]-re[a]+3)%3或re[f1]=(1+re[b]-re[a]+3)%3;</h4><p><strong>2.查找（路径压缩）</strong>：路径压缩就是在搜索的时候找到最远的祖先，然后将父亲节点赋值，对于权值而言，就是找出权值与最远祖先之前所有边权传递的过程，找出节点与父亲节点的关系，依次传递即可。</p><h4 id="设在同一树内，3号节点父亲是2号，2号父亲是根1号。与父亲的关系依次为re-3-，re-2-，路径压缩后权值为re-3-撇。-1"><a href="#设在同一树内，3号节点父亲是2号，2号父亲是根1号。与父亲的关系依次为re-3-，re-2-，路径压缩后权值为re-3-撇。-1" class="headerlink" title="设在同一树内，3号节点父亲是2号，2号父亲是根1号。与父亲的关系依次为re[3]，re[2]，路径压缩后权值为re[3]撇。"></a>设在同一树内，3号节点父亲是2号，2号父亲是根1号。与父亲的关系依次为re[3]，re[2]，路径压缩后权值为re[3]撇。</h4><p>![img](P2024 [NOI2001]食物链.assets/psb)</p><h3 id="显然，re-3-撇-re-3-re-2-3"><a href="#显然，re-3-撇-re-3-re-2-3" class="headerlink" title="显然，re[3]撇=(re[3]+re[2])%3"></a>显然，re[3]撇=(re[3]+re[2])%3</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PII pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">50005</span>;<br><br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> p[N],d[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]!=x)<br>    &#123;<br>        <span class="hljs-keyword">int</span> t=<span class="hljs-built_in">Find</span>(p[x]);<br>        d[x]+=d[p[x]];<br>        p[x]=t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>    cin &gt;&gt;n&gt;&gt;m;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        p[i]=i;<br><br>    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> a,x,y;<br>        cin &gt;&gt;a&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(x&gt;n||y&gt;n)<br>            res++;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">int</span> px=<span class="hljs-built_in">Find</span>(x),py=<span class="hljs-built_in">Find</span>(y);<br>            <span class="hljs-keyword">if</span>(a==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(px==py&amp;&amp;(d[x]-d[y])%<span class="hljs-number">3</span>)<br>                    res++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(px!=py)<br>                &#123;<br>                    p[px]=py;<br>                    d[px]=d[y]-d[x];<span class="hljs-comment">//</span><br>                &#125;<br><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a==<span class="hljs-number">2</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(px==py &amp;&amp;(d[x]-d[y]<span class="hljs-number">-1</span>)%<span class="hljs-number">3</span>)<br>                    res++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(px!=py)<br>                &#123;<br>                    p[px]=py;<br>                    d[px]=d[y]+<span class="hljs-number">1</span>-d[x];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt;res&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>STL二分+DFS</title>
    <link href="/2020/06/28/STL%E4%BA%8C%E5%88%86+DFS/"/>
    <url>/2020/06/28/STL%E4%BA%8C%E5%88%86+DFS/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>定义一个数字为幸运数字当且仅当它的所有数位都是4或者7。<br> 比如说，47、744、4都是幸运数字而5、17、467都不是。<br> 定义next(x)为大于等于x的第一个幸运数字。给定l，r，请求出next(l) + next(l + 1) + … + next(r - 1) + next(r)。</p><p>输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">两个整数l和<span class="hljs-built_in">r</span> (<span class="hljs-number">1</span> &lt;= l &lt;= <span class="hljs-built_in">r</span> &lt;= <span class="hljs-number">1000</span>,<span class="hljs-number">000</span>,<span class="hljs-number">000</span>)。<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">一个数字表示答案。<br></code></pre></td></tr></table></figure><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先dfs打表存下10^9以下的幸运数，之后对于这个幸运数数组从小到大排序，用二分去查找l和r在其中的相对位置（当然用<strong>lower_bound</strong>和<strong>upper_bound</strong>）<br>然后对于范围中的每一个幸运数字：<br>ans += ( min ( a[i] , r) - l + 1) * a[i];<br>注意的是这个l要实时更新。</p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>ll a[<span class="hljs-number">3000</span>];<br><span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1000000000</span>)<br>        <span class="hljs-keyword">return</span> ;<br>    x*=<span class="hljs-number">10</span>;<br>    ll y=x+<span class="hljs-number">4</span>;<br>    a[cnt]=y;<br>    cnt++;<br>    <span class="hljs-built_in">dfs</span>(x+<span class="hljs-number">4</span>);<br>    y=x+<span class="hljs-number">7</span>;<br>    a[cnt]=y;<br>    cnt++;<br>    <span class="hljs-built_in">dfs</span>(x+<span class="hljs-number">7</span>);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br><br>    ll l,r;<br>    cin &gt;&gt;l&gt;&gt;r;<br><br>    <span class="hljs-built_in">sort</span>(a,a+cnt+<span class="hljs-number">1</span>);<br><br>    ll ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> L=<span class="hljs-built_in">lower_bound</span>(a,a+cnt+<span class="hljs-number">1</span>,l)-a;<br><br>    <span class="hljs-keyword">int</span> R=<span class="hljs-built_in">upper_bound</span>(a,a+cnt+<span class="hljs-number">1</span>,r)-a;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=L; i&lt;=R; i++)<br>    &#123;<br>        ans+=a[i]*(<span class="hljs-built_in">min</span>(a[i],r)-l+<span class="hljs-number">1</span>);<br>        l=a[i]+<span class="hljs-number">1</span>;<br>    &#125;<br><br>    cout &lt;&lt;ans&lt;&lt;endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//以下是求和时较麻烦的写法</span><br><span class="hljs-comment">/*for(int i=1;i&lt;=ant;i++)&#123;</span><br><span class="hljs-comment">        if(s[i]&gt;=l)&#123;</span><br><span class="hljs-comment">            if(s[i]&lt;=r)&#123;</span><br><span class="hljs-comment">                ans+=(s[i]-l+1)*s[i];//最小区间长度乘对应的幸运数字则为这个区间幸运数值的和 </span><br><span class="hljs-comment">                l=s[i]+1;</span><br><span class="hljs-comment">            &#125; </span><br><span class="hljs-comment">            else&#123;</span><br><span class="hljs-comment">                ans+=(r-l+1)*s[i];//最小区间长度乘对应的幸运数字则为这个区间幸运数值的和 </span><br><span class="hljs-comment">                l=r+1;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        if(l&gt;r)&#123;//若l&gt;r，则遍历结束，输出答案 </span><br><span class="hljs-comment">            cout&lt;&lt;ans;</span><br><span class="hljs-comment">            return 0; </span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>贪心：巨石滚滚</title>
    <link href="/2020/06/23/%E8%B4%AA%E5%BF%83%EF%BC%9A%E5%B7%A8%E7%9F%B3%E6%BB%9A%E6%BB%9A/"/>
    <url>/2020/06/23/%E8%B4%AA%E5%BF%83%EF%BC%9A%E5%B7%A8%E7%9F%B3%E6%BB%9A%E6%BB%9A/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><hr><p><strong>题目描述：</strong><br>帕秋莉掌握了一种土属性魔法<br>她使用这种魔法建造了一个大型的土球，并让其一路向下去冲撞障碍<br>土球有一个稳定性x，如果x &lt; 0，它会立刻散架<br>每冲撞一个障碍，土球会丧失ai的稳定性，冲撞之后，又会从障碍身上回馈bi的稳定性<br>帕秋莉想知道，如果合理的安排障碍的顺序，在保证土球不散架的情况下，是否可以将障碍全部撞毁呢？</p><p><strong>输入描述：</strong><br>输入一个整数T，代表T组数据，每组数据中：<br>前一行两个整数n , m，表示障碍个数和土球的稳定性</p><p>接下来一行两个整数，分别表示障碍的ai和bi</p><p><strong>输出描述：</strong><br>若可以，输出“Yes”(不含引号)，否则输出“No”(不含引号)</p><hr><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p><strong>贪心策略</strong>：</p><ol><li>首先我们知道，<strong>贪心肯定贪心在排序上面</strong></li><li>然后要注意一点就是，我们是先对球损坏a，再修复b，如果损坏了a就使稳定性变成负数了，就结束了。</li><li>所以我们现在的贪心要素有：<strong>a的损坏大小，b的修补大小</strong>。</li><li>数组就分成了两个部分：<strong>前面是稳定性升高</strong>（包括不变）的，<strong>后面是稳定性降低</strong>的。然后我们就要考虑，这两块里面怎么排。</li><li><strong>稳定性升高内部排序规则</strong>：虽然每个都可以让稳定性升高，但是我们还要考虑在升高的过程中这个球会不会烂掉！！<br>这个时候就可能出现，在某一次损坏下，我们这个球会烂掉，但是假如别的撞后不会烂的球帮它升高之后，就不会撞烂了的情况。<br>所以：我们的排序就应该有这一点：<strong>按照损坏程度大小，从小到大排序</strong>（也就是在为下一个球的情况做贡献）。</li><li><strong>稳定性降低内部排序规则</strong>：这个时候我们不应该考虑自己这个球会不会烂掉，因为该烂掉总会烂掉。但我们要保证下一个更不容易烂掉。<br>所以我说的：不用在乎自己的意思是，如果我的破坏值已经很大了，怎么换都没有意义，一样会烂掉。<br>然后我说的要为下一个球考虑就是：让下一个的时候，我们的稳定性能更高，也就是这一个的回复值要更大。<br>所以我们的排序就应该有这一点：<strong>按照恢复程度的大小，从大到小排序</strong>（让下一个有更多空间去破坏）。</li></ol><p><strong>操作</strong>：</p><ol><li><p>我们在这里用到一个方便的就是STL库里面的sort函数。我们这里写一个cmp函数，也可以重载运算符。</p></li><li><p>我在这里是重载运算符，因为这样可以大幅提高排序效率（两个写起来是一样的）。</p></li><li><p>因为我们在这里有两个因素：a的损坏大小，b的修补大小。所以就有<strong>四种情况</strong>（我们假设在数组里面靠前面的是u，靠后面的是v）。</p></li><li><p>&lt;1&gt;假如u，v稳定性都升高</p><p>，我们按照损坏程度升序排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (a &lt;= b &amp;&amp; v.a &lt;= v.b) <span class="hljs-keyword">return</span> a &lt; v.a;<br></code></pre></td></tr></table></figure></li><li><p>&lt;2&gt;假如u稳定性升高，v稳定性降低</p><p>，我们顺序不用变（因为稳定性升高的要在前面）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (a &lt;= b &amp;&amp; v.a &gt; v.b) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure></li><li><p>&lt;3&gt;假如u稳定性降低，v稳定性升高</p><p>，我们交换顺序（理由同上）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (a &gt; b &amp;&amp; v.a &lt;= v.b) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li><li><p>&lt;4&gt;假如u，v稳定性都降低</p><p>，我们按照修补程度降序排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>  (a  &gt;  b  &amp;&amp;  v.a  &gt;  v.b)  <span class="hljs-keyword">return</span> b &gt; v.b;<br></code></pre></td></tr></table></figure></li></ol><p><strong>代码</strong>：</p><ol><li>输入数组。</li><li>排个序咯。</li><li>然后循环遍历，判断是否会挂（损坏的时候是否耐久度小于0），用flag标记。</li></ol><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdbool&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IOS ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); </span><br><br><span class="hljs-comment">//代码预处理区</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">5e5</span> + <span class="hljs-number">7</span>; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> a, b;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> Node&amp; v) <span class="hljs-keyword">const</span> &#123;<br>        <span class="hljs-keyword">if</span> (a &lt;= b &amp;&amp; v.a &lt;= v.b) <span class="hljs-keyword">return</span> a &lt; v.a;<br>        <span class="hljs-comment">//如果两个都可以增加，先增加消耗小的（让后面消耗大的回复块有机会）</span><br>        <span class="hljs-keyword">if</span> (a &lt;= b &amp;&amp; v.a &gt; v.b) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (a &gt; b &amp;&amp; v.a &lt;= v.b) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//如果一个可以增加，另一个不可以，就让可以增加的在前面</span><br>        <span class="hljs-keyword">if</span>  (a  &gt;  b  &amp;&amp;  v.a  &gt;  v.b)  <span class="hljs-keyword">return</span> b &gt; v.b;<br>        <span class="hljs-comment">//剩下的就是都不能增加的情况，就让回复多的先</span><br>    &#125;<br>&#125; stone[MAX];<br><span class="hljs-comment">//全局变量区 </span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    IOS;<br>    <span class="hljs-keyword">int</span> T; cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--) &#123;<br>        ll n, m; cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            cin &gt;&gt; stone[i].a &gt;&gt; stone[i].b;<br>        <span class="hljs-built_in">sort</span>(stone + <span class="hljs-number">1</span>, stone + <span class="hljs-number">1</span> + n);<br>        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<span class="hljs-comment">//flag=1表示石头没散架</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n &amp;&amp; flag; i++)<br>            <span class="hljs-keyword">if</span> (m - stone[i].a &lt; <span class="hljs-number">0</span>) flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> m -= stone[i].a - stone[i].b;<br>        cout &lt;&lt; (flag ? <span class="hljs-string">&quot;Yes&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><span class="hljs-comment">//函数区</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>枚举+贪心：矩阵消除游戏</title>
    <link href="/2020/06/21/%E6%9E%9A%E4%B8%BE+%E8%B4%AA%E5%BF%83%EF%BC%9A%E7%9F%A9%E9%98%B5%E6%B6%88%E9%99%A4%E6%B8%B8%E6%88%8F/"/>
    <url>/2020/06/21/%E6%9E%9A%E4%B8%BE+%E8%B4%AA%E5%BF%83%EF%BC%9A%E7%9F%A9%E9%98%B5%E6%B6%88%E9%99%A4%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>题目描述</strong>：牛妹在玩一个名为矩阵消除的游戏，矩阵的大小是n行m列，第行第j列的单元格的权值为aij，牛妹可以进行k个回合的游戏，在每个回合，牛妹可以选择-行或者选择一列，然后将这一行或者这一列的所有单元格中的权值变为0，同时牛妹的分数会加上这一行或者这一列中的所有单元格的权值的和。<br>牛妹想最大化她的得分，球球你帮帮她吧！<br><strong>输入描述</strong>：第一行三个整数n，m，k接下来n行每行m个整数表示矩阵中各个单元格的权值。<br><strong>输出描述</strong>：输出一个整数表示牛妹能获得的最大分数。</p><p><a href="https://ac.nowcoder.com/acm/problem/200190">矩阵消除游戏</a></p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题我们要选最大值，当然可以想到这是一道<strong>贪心的题目</strong>。</p><ul><li>但是贪心方法值得我们考究。因为<strong>我理所当然的贪错了</strong>。</li></ul><p><strong>我的贪心策略</strong>：</p><ol><li>首先，我们要<strong>贪心贪出</strong>最大的来<strong>对吧，那我们当然就会想到：</strong>从最大的开始选咯。</li><li>所以每次从行和列中选出一个最大的来进行行列删除。</li><li>删除k次就行了。</li></ol><p><strong>错误原因</strong>：</p><ol><li>根本的错误就是我<strong>理所当然的认为我的贪心策略是对的</strong>了。其实<strong>取个反例</strong>就知道不对了。</li><li>不对的理由是：因为<strong>行选取了最大的之后，会对列产生影响</strong>，因为用到了列的数据嘛。</li><li>但是如果<strong>只对行或列贪心的话就不会产生这种问题</strong>了，因为互相之间没有干扰。</li></ol><p><strong>新的贪心策略</strong>：</p><ol><li>我们上面也已经讲到了新的贪心策略：就是<strong>只对行或列进行贪心</strong>！那另外的一个（行或列）呢？就枚举呗！</li><li>其实我一开始都不明白为什么<strong>数据会这么小</strong>，是不是打错了，居然只有15。原来是枚举用的（其实很多时候，数据就是提示）。</li><li>所以这里我们就用<strong>二进制枚举+贪心</strong>。</li></ol><p><strong>操作</strong></p><ol><li><strong>二进制枚举和贪心我就不详细讲解了</strong>。</li><li>我们就枚举行的每一种情况，枚举的时候，<strong>二进制1的数量就是选取行的数量</strong>，<strong>二进制1的位置就是选出行的位置</strong>。</li><li>然后<strong>算出对应的列和与选取的列的数量</strong>（为啥要算，每次不一样吗？确实不一样，因为每次删除的行不一样呀）。<strong>给列排个序，按照从大到小选</strong>就好了。</li></ol><p><strong>代码</strong>：</p><ol><li>首先输入数据并初始化我们的行和。</li><li>然后<strong>特判</strong>一下K是不是比行和列还大，还大确实就和取满是一样的了。</li><li>接下来就是<strong>外循环二进制枚举</strong>了。</li><li>然后里面就先<strong>得到当前行的选取情况，和行选取数</strong>。并<strong>特判</strong>不存在的情况。</li><li>然后<strong>求出这种情况下，每一列的列和</strong>。</li><li>给列和<strong>排个序</strong>，选最大的几个（几个就是指：总选取数 - 行选取数）。</li><li>最后每个最大的比较一下，<strong>选出二进制枚举里面每一种可能中最大的</strong>，输出就好了。</li></ol><p>ps. 我来细细讲讲01串枚举：<br>  所谓01串枚举，就是我们在每个个体都面对两种选择的时候，可以用一个01串表示，比如说对于本题，每一行有选和不选两种可能，假设有5行的话，我们就可以用一个长度为5的01串来表示，0表示不选1表示选，就像一个bool数组一样，如：01001 表明第134行不选，第25行要选。<br>  只是用一个数字来表示比用数字表示方便，为什么方便呢？因为所有长度小于n的01串，转成十进制之后就是所有小于2^{n}的数字，这样从0到2^{n}-1枚举数字就是从00…00枚举到11…11。这样比写个搜索枚举所有选和不选的情况快乐吧！</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">int</span> a[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">int</span> c[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<br>    ll ans=<span class="hljs-number">0</span>;<br>    ll sumh[<span class="hljs-number">20</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br>    ll suml[<span class="hljs-number">20</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">bool</span> hang[<span class="hljs-number">20</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-keyword">int</span> n,m,k;<br><br>    cin &gt;&gt;n&gt;&gt;m&gt;&gt;k;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; j++)<br>        &#123;<br>            cin &gt;&gt;a[i][j];<br>            c[i][j]=a[i][j];<br>            sumh[i]+=a[i][j];<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(k&gt;n||k&gt;m)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(n&gt;=m)<br>            k=m;<br>        <span class="hljs-keyword">else</span><br>            k=n;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> num=<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,n)<span class="hljs-number">-1</span>;<span class="hljs-comment">//2,n</span><br>    <span class="hljs-keyword">int</span> numh;<br>    <span class="hljs-keyword">int</span> numl;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>; t&lt;=num; t++)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(suml,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(suml));<br>        <span class="hljs-built_in">memset</span>(hang,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(hang));<br>        <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> r=t;<br>        <span class="hljs-keyword">while</span>(r)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(r&amp;<span class="hljs-number">1</span>)<br>            &#123;<br>                cnt++;<br>                hang[j]=<span class="hljs-number">1</span>;<br>                r &gt;&gt;=<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                r &gt;&gt;=<span class="hljs-number">1</span>;<br>            &#125;<br>            j++;<br>        &#125;<br>        numh=cnt;<br>        numl=k-cnt;<br>        <span class="hljs-keyword">if</span>(numl&gt;k||numl&lt;<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        ll maxs=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> g=<span class="hljs-number">1</span>; g&lt;=n; g++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(hang[g])<br>            &#123;<br>                maxs+=sumh[g];<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> p=<span class="hljs-number">1</span>; p&lt;=m; p++)<br>                &#123;<br>                    a[g][p]=<span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)<br>            &#123;<br>                suml[i]+=a[j][i];<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-built_in">sort</span>(suml+<span class="hljs-number">1</span>,suml+m+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=numl; i++)<br>        &#123;<br>            maxs+=suml[m-i+<span class="hljs-number">1</span>];<br>        &#125;<br>        ans=<span class="hljs-built_in">max</span>(ans,maxs);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; j++)<br>            &#123;<br><br>                a[i][j]=c[i][j];<br><br>            &#125;<br><br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt;ans&lt;&lt;endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.nowcoder.net/n/6bcd181f88684b9a85c359f84a44539e?f=comment">https://blog.nowcoder.net/n/6bcd181f88684b9a85c359f84a44539e?f=comment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/2020/02/28/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <url>/2020/02/28/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章：Hexo部署"><a href="#第一章：Hexo部署" class="headerlink" title="第一章：Hexo部署"></a>第一章：Hexo部署</h2><p>— #安装Nodejs<br>node -v #查看node版本<br>npm -v #查看npm版本<br>npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a> #安装淘宝的cnpm 管理器<br>cnpm -v #查看cnpm版本<br>cnpm install -g hexo-cli #安装hexo框架<br>hexo -v #查看hexo版本<br>mkdir blog #创建blog目录<br>cd blog #进入blog目录<br>sudo hexo init #生成博客 初始化博客<br>hexo s #启动本地博客服务<br><a href="http://localhost:4000/">http://localhost:4000/</a> #本地访问地址<br>hexo n “我的第一篇文章” #创建新的文章<br>#返回blog目录<br>hexo clean #清理<br>hexo g #生成<br>#Github创建一个新的仓库 YourGithubName.github.io<br>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件<br>-—<br>#配置_config.yml<br>-—-<br># Deployment<br>## Docs: <a href="https://hexo.io/docs/deployment.html">https://hexo.io/docs/deployment.html</a><br>deploy:<br>type: git<br>repo: <a href="https://github.com/YourGithubName/YourGithubName.github.io.git">https://github.com/YourGithubName/YourGithubName.github.io.git</a><br>branch: master<br>-—-<br>hexo d #部署到Github仓库里<br><a href="https://yourgithubname.github.io/">https://YourGithubName.github.io/</a> #访问这个地址可以查看博客</p><p>git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia #下载yilia主题到本地</p><p>#修改hexo根目录下的 _config.yml 文件 ： theme: yilia</p><p>hexo c #清理一下<br>hexo g #生成<br>hexo d #部署到远程Github仓库<br><a href="https://yourgithubname.github.io/">https://YourGithubName.github.io/</a> #查看博客</p><h2 id="第二章：Hexo发出博客"><a href="#第二章：Hexo发出博客" class="headerlink" title="第二章：Hexo发出博客"></a>第二章：Hexo发出博客</h2><p>文章的位置：C:\Users\Admin\blog\source_posts</p><p>hexo n “文章名”</p><p>编辑的方法：</p><p>vim 文章名.md</p><p>退出编辑</p><p>esc :wq</p><p>hexo clean</p><p>hexo g</p><p>hexo s</p><p>hexo d</p><p>即完成博客的发布</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.codesheep.cn/">www.codesheep.cn</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
